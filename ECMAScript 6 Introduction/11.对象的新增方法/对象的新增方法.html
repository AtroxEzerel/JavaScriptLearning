<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11.对象的新增方法</title>
  </head>
  <body>
    <ul>
      <li>对象的新增方法</li>
      <li>1.Object.is()</li>
      <li>2.Object.assign()</li>
      <li>3.Object.getOwnPropertyDescriptors()</li>
      <li>4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</li>
      <li>5.Object.keys()，Object.values()，Object.entries()</li>
      <li>6.Object.fromEntries()</li>
    </ul>
    <script>
      // t=>target s=>source o=>object r=>result m=>merge opt=>option

      //1.Object.is()
      //Object.is():用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
      console.log(Object.is("foo", "foo")); //true
      console.log(Object.is({}, {})); //false
      console.log(Object.is(+0, -0)); //flse
      console.log(Object.is(NaN, NaN)); //true
      //ES5 可以通过下面的代码，部署Object.is。
      Object.defineProperty(Object, "Is", {
        value: function (x, y) {
          if (x === y) {
            // 针对+0 不等于 -0的情况
            return x !== 0 || 1 / x === 1 / y;
          }
          // 针对NaN的情况
          return x !== x && y !== y;
        },
        configurable: true,
        enumerable: false,
        writable: true,
      });

      //2.Object.assign()
      //Object.assign()方法用于对象的合并，将源对象（s）的所有可枚举属性，复制到目标对象（t）。
      const t1 = { a: 1 };
      const s1 = { b: 2 };
      const s2 = { c: 3 };
      console.log(Object.assign(t1, s1, s2)); //{    "a": 1,"b": 2,"c": 3}
      //Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。
      //注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
      const t2 = { a: 1, b: 1 };
      const s3 = { b: 2, c: 2 };
      const s4 = { c: 3 };
      const r2 = Object.assign(t2, s3, s4);
      console.log(r2); //{"a": 1,"b": 2,"c": 3}
      //如果只有一个参数，Object.assign()会直接返回该参数。
      const obj1 = { a: 1 };
      console.log(Object.assign(obj1) === obj1); //true
      //如果该参数不是对象，则会先转成对象，然后返回。
      console.log(typeof Object.assign(2)); //object
      //由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
      /* console.log(Object.assign(undefined)); //Uncaught TypeError: Cannot convert undefined or null to object
            console.log(Object.assign(null)); //Uncaught TypeError: Cannot convert undefined or null to object */
      //如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。
      const obj2 = { a: 1 };
      console.log(Object.assign(obj2, undefined) === obj2);
      console.log(Object.assign(obj2, null) === obj2);
      //其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
      const v1 = "abc";
      const v2 = true;
      const v3 = 10;
      const v4 = [1, 2, 3];
      const r3 = Object.assign({}, v1, v2, v3);
      console.log(r3); //{"0": "a","1": "b","2": "c"}
      //如果再加入数组v4则r3会被替换{"0": 1,"1": 2,"2": 3}
      //上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。
      console.log(Object(v1)); // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
      console.log(Object(v2)); // {[[PrimitiveValue]]: true}
      console.log(Object(v3)); //  {[[PrimitiveValue]]: 10}
      //上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign()拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝
      //Object.assign()拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
      const r4 = Object.assign(
        { b: "c" },
        Object.defineProperty({}, "invisible", {
          enumerable: false,
          value: "hello",
        })
      );
      console.log(r4); //{"b": "c"}
      //上面代码中，Object.assign()要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。
      /*
            Object.defineProperty()
            Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
            语法
              Object.defineProperty(obj, prop, descriptor)
              参数
              obj
                  要定义属性的对象。
              prop
                  要定义或修改的属性的名称或 Symbol 。
              descriptor
                  要定义或修改的属性描述符。
              返回值
                  被传递给函数的对象。
            */
      //属性名为 Symbol 值的属性，也会被Object.assign()拷贝。
      const r5 = Object.assign({ a: "b" }, { [Symbol("c")]: "d" });
      console.log(r5); //// { a: 'b', Symbol(c): 'd' }

      //注意点
      //（1）浅拷贝
      //Object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
      const obj3 = { a: { b: 1 } };
      const obj4 = Object.assign({}, obj3);
      console.log(obj4); //{"a": {"b": 1}}
      obj3.a.b = 2;
      console.log(obj4); //{"a": {"b": 2}}
      //上面代码中，源对象obj1的a属性的值是一个对象，Object.assign()拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。

      //（2）同名属性的替换
      //对于这种嵌套的对象，一旦遇到同名属性，Object.assign()的处理方法是替换，而不是添加。
      const t3 = { a: { b: "b", c: "c" } };
      const s5 = { a: { b: "hello" } };
      console.log(Object.assign(t3, s5)); //{"a": {"b": "hello"}}
      //上面代码中，t对象的a属性被s对象的a属性整个替换掉了，而不会得到{ a: { b: 'hello', d: 'e' } }的结果。这通常不是开发者想要的，需要特别小心。

      //（3）数组的处理
      //Object.assign()可以用来处理数组，但是会把数组视为对象。
      console.log(Object.assign([1, 2, 3], [4, 5])); //[4,5,3]
      //上面代码中，Object.assign()把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。

      //（4）取值函数的处理
      //Object.assign()只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
      const t4 = {};
      const s6 = {
        get foo() {
          return 1;
        },
      };
      console.log(Object.assign(t4, s6)); //{"foo": 1}
      //上面代码中，source对象的foo属性是一个取值函数，Object.assign()不会复制这个取值函数，只会拿到值以后，将这个值复制过去。

      //常见用途
      //（1）为对象添加属性
      class point {
        constructor(x, y) {
          Object.assign(this, { x: 1, y: 1 });
        }
      }
      console.log(point);
      const point1 = new point();
      console.log(point1); //{"x": 1,"y": 1}
      //上面方法通过Object.assign()方法，将x属性和y属性添加到Point类的对象实例。

      //（2）为对象添加方法
      class SomeClass {}
      Object.assign(SomeClass.prototype, {
        someMethod(arg1, arg2) {
          return arg1 + arg2;
        },
        anotherMethod() {
          console.log("assign为对象添加方法");
        },
      });
      console.log(SomeClass.prototype); //{someMethod: ƒ, anotherMethod: ƒ, constructor: ƒ}
      // 等同于下面的写法
      SomeClass.prototype.someMethod = function (arg1, arg2) {
        return arg1 + arg2;
      };
      SomeClass.prototype.anotherMethod = function () {
        console.log("为对象添加方法");
      };
      //上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign()方法添加到SomeClass.prototype之中。

      //（3）克隆对象
      function clone(o) {
        return Object.assign({}, o);
      }
      const o1 = { name: "james", age: "36" };
      console.log(clone(o1)); //{name: 'james', age: '36'}
      //上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。
      //不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。
      function inheritClone(o) {
        let oProto = Object.getPrototypeOf(o);
        return Object.assign(Object.create(oProto), o);
      }

      //（4）合并多个对象
      //将多个对象合并到某个对象。
      const m1 = Object.assign(t1, s1, s2, s3);
      console.log(m1); //{a: 1, b: 2, c: 2}
      //如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。
      const m2 = Object.assign({}, s1, s2, s3);
      console.log(m2); //{b: 2, c: 2}

      //（5）为属性指定默认值
      const DEFAULTS = {
        logLevel: 0,
        outputFormat: "html",
      };
      function processContent(opt) {
        opt = Object.assign({}, DEFAULTS, opt);
        console.log(opt);
      }
      const opt1 = { city: "beijing", location: "north", logLevel: 1 };
      processContent(opt1);
      //上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign()方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖DEFAULTS的属性值。
      //注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。
      const DEFAULTS2 = {
        url: {
          host: "example.com",
          port: 7070,
        },
      };
      function processContent2(opt) {
        opt = Object.assign({}, DEFAULTS2, opt);
        console.log(opt);
      }
      processContent2({ url: { port: 8000 } }); //{"url": {"port": 8000}}
      //上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。

      //3.Object.getOwnPropertyDescriptors()
      //ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）
      //ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。
      const o2 = {
        foo: 123,
        get Bar() {
          return "abc";
        },
      };
      console.log(Object.getOwnPropertyDescriptors(o2));
      // { foo:
      //    { value: 123,
      //      writable: true,
      //      enumerable: true,
      //      configurable: true },
      //   bar:
      //    { get: [Function: get bar],
      //      set: undefined,
      //      enumerable: true,
      //      configurable: true } }
      //上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。

      //该方法的实现非常容易。
      function getOwnPropertyDescriptors(obj) {
        const result = {};
        for (let key of Reflect.ownKeys(obj)) {
          result[key] = Object.getOwnPropertyDescriptor(obj, key);
        }
        return result;
      }
      console.log(getOwnPropertyDescriptors(o2)); //ditto

      //该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。
      const s7 = {
        set foo(value) {
          console.log(value);
        },
      };
      const t5 = {};
      Object.assign(t5, s7);
      console.log(Object.getOwnPropertyDescriptors(t5, "foo"));
      // { value: undefined,
      //   writable: true,
      //   enumerable: true,
      //   configurable: true }
      //上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。

      //这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。
      const s8 = {
        set foo(value) {
          console.log(value);
        },
      };
      const t6 = {};
      Object.defineProperties(t6, Object.getOwnPropertyDescriptors(s8));
      console.log(Object.getOwnPropertyDescriptor(t6, "foo"));
      // { get: undefined,
      //   set: [Function: set foo],
      //   enumerable: true,
      //   configurable: true }
      //上面代码中，两个对象合并的逻辑可以写成一个函数。
      const shallowMerge = (target, source) =>
        Object.defineProperties(
          target,
          Object.getOwnPropertyDescriptors(source)
        );

      //Object.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝
      const clone3 = Object.create(
        Object.getPrototypeOf(obj4),
        Object.getOwnPropertyDescriptors(obj4)
      );
      // 或者
      const shallowClone = (obj4) =>
        Object.create(
          Object.getPrototypeOf(obj4),
          Object.getOwnPropertyDescriptors(obj4)
        );
      //上面代码会克隆对象obj。

      //另外，Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。
      //有了Object.getOwnPropertyDescriptors()，我们就有了另一种写法。
      const prot = {};
      const o4 = Object.create(
        prot,
        Object.getOwnPropertyDescriptors({
          foo: 123,
        })
      );

      //Object.getOwnPropertyDescriptors()也可以用来实现 Mixin（混入）模式。
      let mix = (object) => ({
        with: (...mixins) =>
          mixins.reduce(
            (c, mixin) =>
              Object.create(c, Object.getOwnPropertyDescriptors(mixin)),
            object
          ),
      });
      // multiple mixins example
      let a = { a: "a" };
      let b = { b: "b" };
      let c = { c: "c" };
      let d = mix(c).with(a, b);
      console.log(d);
      //d.c => "c"
      //d.b => "b"
      //d.a => "a"

      //4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()
      //__proto__属性
      //__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）
      //因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。
      //如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。
      console.log(Object.getPrototypeOf({ __proto__: null })); //null

      //Object.setPrototypeOf()
      //Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。
      /*
      // 格式
      Object.setPrototypeOf(object, prototype);
      // 用法
      const o = Object.setPrototypeOf({}, null);
      */
      //该方法等同于下面的函数。
      function setPrototypeOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
      }
      //下面是一个例子。
      let p1 = {};
      let o5 = { x: 10 };
      p1.y = 20;
      p1.z = 30;
      Object.setPrototypeOf(o5, p1);
      console.log(o5); //x:10 y:20 z:30
      //上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。
      //如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。
      //由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。
      /*
      Object.setPrototypeOf(undefined, {});
      // TypeError: Object.setPrototypeOf called on null or undefined
      Object.setPrototypeOf(null, {});
      // TypeError: Object.setPrototypeOf called on null or undefined
      */

      //Object.getPrototypeOf()
      //用于读取一个对象的原型对象。
      Object.getPrototypeOf("");
      //下面是一个例子。
      function Rectangle() {
        // ...
      }
      const rec = new Rectangle();
      console.log(Object.getPrototypeOf(rec) === Rectangle.prototype); //true
      //如果参数不是对象，会被自动转为对象。
      // 等同于 Object.getPrototypeOf(Number(1))
      Object.getPrototypeOf(1);
      // Number {[[PrimitiveValue]]: 0}

      // 等同于 Object.getPrototypeOf(String('foo'))
      Object.getPrototypeOf("foo");
      // String {length: 0, [[PrimitiveValue]]: ""}

      // 等同于 Object.getPrototypeOf(Boolean(true))
      Object.getPrototypeOf(true);
      // Boolean {[[PrimitiveValue]]: false}
      //如果参数是undefined或null，它们无法转为对象，所以会报错。
      /*
       Object.getPrototypeOf(null);
      // TypeError: Cannot convert undefined or null to object
      Object.getPrototypeOf(undefined);
      // TypeError: Cannot convert undefined or null to object
      */

      //5.Object.keys()，Object.values()，Object.entries()
      //Object.keys()
      //ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
      let o7 = { foo: "bar", baz: 42 };
      console.log(Object.keys(o7)); // ['foo', 'baz']
      //ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。
      let { keys, values, entries } = Object;
      let o8 = { a: 1, b: 2, c: 3 };
      for (let key of keys(o8)) {
        console.log(key); // 'a', 'b', 'c'
      }
      for (let value of values(o8)) {
        console.log(value); // 1, 2, 3
      }
      for (let [key, value] of entries(o8)) {
        console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
      }

      //Object.values()
      //ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
      let o9 = { foo: "foo", br: "123" };
      console.log(Object.values(o9)); //["foo","123"]
      //返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致
      let o10 = { 100: "a", 46: "b", 58: "c" };
      console.log(Object.values(o10)); //['b', 'c', 'a']
      //上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。
      //Object.values只返回对象自身的可遍历属性。
      let o11 = Object.create({}, { p: { value: 42 } });
      console.log(Object.values(o11)); //[]
      //上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。
      let o12 = Object.create({}, { p: { value: 50, enumerable: true } });
      console.log(Object.values(o12)); //[50]
      //Object.values会过滤属性名为 Symbol 值的属性。
      console.log(Object.values({ [Symbol()]: 123, foo: "bar" })); //['bar']
      //如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。
      console.log(Object.values("HelloWorld!")); // ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd', '!']
      //上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。
      // 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。
      console.log(Object.values(42)); //[]
      console.log(Object.values(true)); //[]

      //Object.entries()
      //Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
      let o13 = { name: "jack", sex: "male", age: 28, address: "UK" };
      console.log(Object.entries(o13));
      /*       
      ['name', 'jack']
      ['sex', 'male']
      ['age', 28]
      ['address', 'UK']
      */
      //除了返回值不一样，该方法的行为与Object.values基本一致。
      //如果原对象的属性名是一个 Symbol 值，该属性会被忽略。
      console.log(Object.entries({ [Symbol()]: 123, foo: "abc" })); //[ [ 'foo', 'abc' ] ]
      //上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。
      //Object.entries的基本用途是遍历对象的属性
      let o14 = { one: 1, two: 2 };
      for (let [k, v] of Object.entries(o14)) {
        console.log(`${JSON.stringify(k)}:${JSON.stringify(v)}`);
      } //"one":1 "two":2
      //Object.entries方法的另一个用处是，将对象转为真正的Map结构。
      let o15 = { foo: "bar", baz: 42 };
      const map1 = new Map(Object.entries(o15));
      console.log(map1); //Map(2) {'foo' => 'bar', 'baz' => 42}
      //自己实现Object.entries方法，非常简单。
      // Generator函数的版本
      function* entries1(obj) {
        for (let key of Object.keys(obj)) {
          yield [key, obj[key]];
        }
      }
      console.log(entries1(o15));
      // 非Generator函数的版本
      function entries2(obj) {
        let arr = [];
        for (let key of Object.keys(obj)) {
          arr.push([key, obj[key]]);
        }
        return arr;
      }
      console.log(entries2(o15));

      //6.Object.fromEntries()
      //Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
      let o16 = [
        ['test1', "test1"],
        ['test2', 12],
      ];
      console.log(Object.fromEntries(o16));//{test1: 'test1', test2: 12}
      //该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。
      let map2 = new Map().set('number',1).set('str','zifuchuan').set('boolen','true')
      console.log(Object.fromEntries(map2));//{number: 1, str: 'zifuchuan', boolen: 'true'}
      //该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。
      console.log(Object.fromEntries(new URLSearchParams('name=lucy&age=18')));//{name: 'lucy', age: '18'}
    </script>
  </body>
</html>
